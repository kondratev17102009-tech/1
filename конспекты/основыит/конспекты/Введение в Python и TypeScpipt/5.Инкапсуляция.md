## Инкапсуляция
Инкапсуляция в объектно-ориентированном программировании (ООП) — это
принцип, который объединяет данные (свойства) и методы, работающие с этими данными, в одну «оболочку», называемую классом. Это также означает скрытие внутренней реализации объекта и ограничение прямого доступа к его данным извне. Взаимодействие с объектом осуществляется только через определенные, публичные методы (геттеры и сеттеры), которые контролируют и обрабатывают эти данные.

### Код на Python

```python
class Car:
    def init(self, brand, model, production_year):
        # 1. Публичные атрибуты (без префикса)
        self.brand = brand
        self.model = model
        
        # 2. Приватный атрибут (для инкапсуляции)
        # Он не должен быть доступен или изменен напрямую снаружи.
        self.__production_year = production_year 
        
        # 3. Защищенный атрибут (используется для внутреннего состояния)
        self._odometer_reading = 0

    # Публичный метод для чтения приватного атрибута (Геттер)
    def get_year(self):
        """Возвращает приватный год выпуска."""
        return self.__production_year

    # Публичный метод для изменения защищенного атрибута с проверкой (Сеттер)
    def drive(self, distance):
        """Увеличивает показания одометра и выводит сообщение."""
        if distance > 0:
            self._odometer_reading += distance
            print(f"Машина {self.brand} проехала {distance} км.")
        else:
            print("Расстояние должно быть положительным числом.")
            
    # Публичный метод для чтения защищенного атрибута
    def get_odometer(self):
        """Возвращает защищенный показатель одометра."""
        return self._odometer_reading

# --- Использование класса ---
my_car = Car("Toyota", "Corolla", 1998)

# Доступ к публичным атрибутам напрямую (нормально)
print(f"Модель: {my_car.brand} {my_car.model}")

# Попытка доступа к приватному атрибуту напрямую (не рекомендуется и не работает просто)
# print(f"Год (Прямой доступ): {my_car.__production_year}") # Вызовет AttributeError
print(f"Год (Через геттер): {my_car.get_year()}")

# Вызов публичного метода для изменения внутреннего состояния
my_car.drive(50)
my_car.drive(100)

# Вызов публичного метода для получения внутреннего состояния
print(f"Общий пробег: {my_car.get_odometer()} км")

# Теоретически, прямой доступ к защищенному атрибуту возможен, но это нарушает инкапсуляцию
# print(f"Прямой доступ к одометру: {my_car._odometer_reading} км")
```

#### Объяснение кода
##### Сокрытие Данных
Мы сделали год выпуска (`production_year`) приватным, используя двойное подчеркивание.
Это скрывает этот атрибут от прямого внешнего изменения.
Чтобы прочитать его, мы предоставили публичный метод `get_year()`, который называется геттером.
##### Контролируемый Доступ и Изменение
Мы инкапсулировали показания одометра (`odometer_reading`) с помощью одного подчеркивания.
Мы не позволяем пользователю просто установить одометр на любое значение (`my_car.odometer_reading = 100000`).
Вместо этого мы предоставили публичный метод `drive(distance)`, который:
Служит сеттером (изменяет данные).
Содержит логику проверки (`if distance > 0:`), гарантируя, что одометр всегда увеличивается корректно, а не просто устанавливается.
Инкапсуляция таким образом обеспечивает, что данные объекта всегда остаются в корректном и согласованном состоянии.

## Наследование
Наследование в ООП — это способ создания иерархии классов, когда новый, дочерний класс получает (наследует) свойства и методы уже существующего родительского класса, что позволяет повторно использовать код и избегать его дублирования. Дочерний класс может расширять или изменять унаследованную функциональность, добавляя свои собственные поля и методы.

### Код на Python
#### 1. Базовый класс (родитель)
Мы определим общий класс `Animal` (Животное), который содержит атрибуты и методы, общие для всех животных.
```python
class Animal:
    def init(self, name, species):
        # Общие атрибуты для всех животных
        self.name = name
        self.species = species

    def make_sound(self):
        """Общий метод для всех животных, который будет переопределен."""
        print("Издает некий звук.")

    def info(self):
        """Метод для вывода общей информации."""
        print(f"Имя: {self.name}, Вид: {self.species}")
```

#### Производные Классы (Потомки)
Теперь мы создадим классы `Dog` (Собака) и `Cat` (Кошка), которые наследуют от класса `Animal`. Они автоматически получают атрибуты (`name`, `species`) и методы (`info`, `make_sound`) родительского класса.

**А. Класс Dog (Наследование и Добавление Новых Методов)**
```python
class Dog(Animal): # Dog наследует от Animal
    def init(self, name, breed):
        # Вызов конструктора родительского класса Animal
        super().init(name, species="Собака")
        # Добавление нового, специфического атрибута
        self.breed = breed
    
    # Переопределение (Overriding) метода родителя
    def make_sound(self):
        """Специфический звук для собаки."""
        print("Гав-гав!")

    # Добавление нового, специфического метода
    def fetch(self):
        """Специфическое действие собаки."""
        print(f"{self.name} приносит палку.")
```

**Б. Класс Cat (Наследование и Переопределение)**

```python
class Cat(Animal): # Cat наследует от Animal
    def init(self, name, color):
        # Вызов конструктора родительского класса Animal
        super().init(name, species="Кошка")
        # Добавление нового, специфического атрибута
        self.color = color

    # Переопределение (Overriding) метода родителя
    def make_sound(self):
        """Специфический звук для кошки."""
        print("Мяу!")
```

#### Демонстрация использования
```python
# Создаем экземпляры классов-потомков

dog = Dog("Рекс", "Немецкая овчарка")
cat = Cat("Мурка", "Рыжий")

## --- 1. Использование Наследованных Методов ---
# Оба объекта используют метод info(), унаследованный от Animal
print("--- Использование Наследованных Методов ---")
dog.info() 
cat.info() 
print("-" * 30)

## --- 2. Демонстрация Переопределения (Overriding) ---
# Каждый объект вызывает свою специфическую версию make_sound()
print("--- Переопределение Методов ---")
dog.make_sound() # Вызывает make_sound() из Dog
cat.make_sound() # Вызывает make_sound() из Cat
print("-" * 30)

## --- 3. Использование Собственных Методов ---
# Только объект Dog имеет метод fetch()

print("--- Собственные Методы ---")
dog.fetch()
cat.fetch() # Вызовет AttributeError: 'Cat' object has no attribute 'fetch'
```

## Полиморфизм
Слово "полиморфизм" происходит от греческих корней: Poly (много) и Morph (форма), то есть "много форм". В программировании это означает, что объекты разных классов могут реагировать на один и тот же метод или оператор по-разному.
В Python полиморфизм проявляется в двух основных формах:

### 1. Полиморфизм через Наследование (Overriding)
Это наиболее классический пример, который мы уже видели в примере с наследованием. Разные классы-потомки, унаследованные от одного родителя, имеют метод с одинаковым названием, но разной реализацией.

**Пример с Животными**

```python
class Animal:
    def speak(self):
        # Базовая реализация, которая будет переопределена
        raise NotImplementedError("Метод speak должен быть реализован в классах-потомках")

class Dog(Animal):
    def speak(self):
        # Специфическая реализация для Dog
        return "Гав-гав!"

class Cat(Animal):
    def speak(self):
        # Специфическая реализация для Cat
        return "Мяу!"

# Создаем список объектов разных типов
animals = [Dog(), Cat()]

# Итерируемся по списку и вызываем метод speak()
# Внешний код не знает, Dog это или Cat, но знает, что у Animal есть speak().
# Исполняется правильная версия метода.
print("--- Полиморфизм через Наследование ---")
for animal in animals:
    # ОДИН и тот же вызов (animal.speak()), 
    # но РАЗНЫЙ результат
    print(animal.speak())
```

В этом случае вызов `animal.speak()` имеет много форм в зависимости от того, на каком объекте (`Dog` или `Cat`) он вызывается.

### 2. Полиморфизм через Утиную Типизацию (Duck Typing)
Поскольку #Python — язык с динамической типизацией, он позволяет объектам не иметь общего наследования, но демонстрировать полиморфизм, если они реализуют один и тот же набор методов.
Принцип "утиной типизации" гласит: "Если оно ходит как утка, плавает как утка и крякает как утка, то это, вероятно, утка". То есть, важен интерфейс (какие методы есть), а не фактический тип (от кого наследуется).

**Пример с Документами**

Мы создадим два класса, не связанных наследованием, но оба имеющих метод `print_content()`:
```python
class WordDocument:
    def print_content(self):
        """Собственный метод печати для документа Word."""
        return "Печать форматированного текста Word..."

class PDFDocument:
    def print_content(self):
        """Собственный метод печати для PDF-файла."""
        return "Печать фиксированного макета PDF..."

# Функции, которые принимают ЛЮБОЙ объект, у которого есть метод print_content
def send_to_printer(document):
    """Принимает полиморфный объект 'document'."""
    print(f"Отправка на принтер: {document.print_content()}")

print("\n--- Полиморфизм через Утиную Типизацию ---")
word = WordDocument()
pdf = PDFDocument()

# ОДНА и та же функция (send_to_printer), 
# но РАЗНЫЙ результат в зависимости от внутреннего типа
send_to_printer(word)
send_to_printer(pdf)
```


В этом примере, функция send_to_printer является полиморфной, поскольку она может обрабатывать объекты WordDocument и PDFDocument одинаковым образом, вызывая print_content(), хотя эти классы не имеют общего родителя.